#5. 다음의 쟁점들을 참고하여 연속적 메모리 할당, 순수 세그먼테이션, 순수 페이징 기법들을 비교하시오.

  - 외부 단편화
    * 연속적 메모리 할당 :
        발생할 가능성이 높다. 
    * 순수 세그먼테이션 : 
        발생 시 유연한 조정이 가능하다.
    * 순수 페이징 : 
        발생 시에 쉽게 조정이 가능하다.

  - 내부 단편화
    * 연속적 메모리 할당 :
        발생할 가능성이 높다. 
    * 순수 세그먼테이션 : 
        발생 시 유연한 조정이 가능하다.
    * 순수 페이징 : 

  - 프로세스 사이의 코드 공유 가능성
    * 연속적 메모리 할당 :
        
    * 순수 세그먼테이션 : 
        논리적인 부분으로 메모리를 구성하기 때문에 쉬운 공유가 가능하다.
    * 순수 페이징 : 

#13. BTV 운영체제는 21-비트 가상 주소를 사용하지만, 특정 임베디드 장치의 경우 물리 메모리 주소로 16-비트를
#   사용한다. 다음 테이블의 항목의 개수는 몇 개인가?

    a. 전통적인 1단계 페이지 테이블
        가상 메모리를 사용하므로 21-비트이다.

    b. 역 페이지 테이블
        물리 메모리를 사용하므로 16-비트이다.

#17. 메모리에 페이지 테이블을 저장하는 페이징 시스템을 생각해 보자.
    a. 만약 메모리 참조가 50 nsec 걸린다면 메모리 참조는 얼마나 걸리는가?
        x * 2 * 50nsec = x번 참조 시 100nsec
    b. TLB를 추가하여 모든 페이지 테이블 참조의 75%를 TLB에서 찾을 수 있다면 실제 메모리 접근 시간은 얼마인가?
        (TLB에 존재하는 페이지 테이블 항목을 찾는 데 2nsec)
        0.25x * (2 * 50nsec) + 0.75x * (2+50nsec) = x (25 + 52*0.75) = x(25+ 39) = x * (64 nsec)

#18. 세그멘테이션과 페이징 기법을 결합하여 사용하는 이유는 무엇 때문인가?
    세그먼테이션은 메모리 영역을 추상화시키고, 페이징은 메모리 영역을 단위화해 분할한다.
    따라서 이 둘을 결합하면 메모리 영역을 유연하게 사용할 수 있다.

